import * as uuid from 'uuid/v4';
import { Type } from '@angular/core';
import * as _ from 'lodash';
import { Property, PropertyOptions, TransformProperty } from './property';
import * as PIXI from 'pixi.js';
import { EntityException } from '../exception/entity/entity';
import { UpdateEntityProperty } from '../ngxs/actions';

function getAllPropertyNames(obj) {
  let props = [];
  do {
    props = props.concat(Object.getOwnPropertyNames( obj ));
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}

const tempPoint = new PIXI.Point();
interface EntityTypes {
  [key: string]: Type<Entity>;
}

export interface PropertyOptionsExt extends PropertyOptions {
  name: string;
  value: any;
}
/**
 * Data which has to be exported for an entity.
 *
 * @interface EntityData
 */
export interface EntityData {
  /** @type {string} The id of the entity. */
  id: string;

  /** @type {string} The type of the entity. */
  type: string;

  /** @type {string} The name of the entity. */
  name: string;

  /** @type {boolean} The visibility of the entity. */
  visibility: boolean;

  /** @type {boolean} The lock state of the entity. */
  locked: boolean;

  [key: string]: any;
}

/** @type {EntityTypes} A map of entity types, which are registred. */
const TYPES: EntityTypes = {};

/**
 * An entity represents any object which can be rendered in a scene.
 * The scene holds a collection/list of entities.
 *
 * @export
 * @abstract
 * @class Entity
 * @extends {PIXI.Container}
 */
export abstract class Entity extends PIXI.Container {
  /** @type {Entity} The parent entity, which may be different from the parent. This will not be exported or parsed. */
  @Property(false) parentEntity: Entity;

  /** @type {string} The internal uuid. It will be generated by default. Implementations can override it, though. */
  @Property({ type: 'string', export: true, editable: false }) id: string;

  /** @type {string} The internal name of this entity.*/
  @Property({ type: 'string', export: true }) name: string;

  /** @type {boolean} The visibility flag for this entity, i.e. will be rendered if `true`. */
  @Property({ type: 'boolean', export: true }) visibility: boolean;

  /** @type {boolean} The lock flag for this entity, i.e. will not be interactive anymore if `true`. */
  @Property({ type: 'boolean', export: true }) locked: boolean;

  /** @type {number} The transparency value. `transparency=1` means `alpha=0` */
  @Property({ type: 'range', export: true, min: 0, max: 100, transform: 100, step: 1 }) transparency: number;

  /** @type {EntityData} The data to export. Should be updated as soon, as changes happen to this entity. */
  protected internalExportData: EntityData;

  /**
   * Registers an entity class.
   * You should use the method to register your entity class, so resolving entity types will works as expected.
   *
   * @param {Type<Entity>} clazz The class to regiter.
   * @param {string} [type=clazz.name.toLowerCase()] You may want to set this, to prevent naming collisions.
   */
  static registerEntityType<T extends Entity>(clazz: Type<T>, type: string = clazz.name.toLowerCase()): void {
    TYPES[type] = clazz;
  }

  /**
   * Resolves an entity class for the given entity type.
   *
   * @param {string} type The entity type.
   * @returns {Type<Entity>} The entity class. Maybe `undefined` if not registered yet.
   */
  static getEntityType(type: string): Type<Entity> {
    return TYPES[type];
  }

  /**
   * Searches for the registered entity type of the given entity.
   *
   * @param {T} entity The entity to find the type for.
   * @returns {string} The type or `undefined` if not found.
   */
  static getEntityTypeOf<T extends Entity>(entity: T): string {
    const proto = Object.getPrototypeOf(entity);
    return _.findKey(TYPES, type => type === proto.constructor);
  }

  constructor(name?: string) {
    super();
    this.internalExportData = {
      id: void 0,
      name: void 0,
      type: Entity.getEntityTypeOf(this),
      visibility: void 0,
      locked: void 0,
      transparency: void 0,
    };
    this.parentEntity = null;
    this.id = uuid();
    this.name = name;
    this.visibility = true;
    this.locked = false;
    this.transparency = 0;
    this.on('change:visibility', val => (this.visible = val));
    this.on('change:transparency', val => (this.alpha = Math.max(0, Math.min(1, 1 - val))));
  }

  /** @type {EntityData} The export data of this entity. */
  get exportData(): EntityData {
    return this.internalExportData;
  }

  /**
   * Exports the current data of this entity.
   * The `exported` event will be triggered before resolving.
   * Override this to your needs, but make sure to call this implementation at the end, so the `exported` event gets
   * emitted right before resolving.
   *
   * @param {string} [target] The target URI. Can be used for calculating relative paths, etc.
   * @returns {Promise<EntityData>} Resolves the exported data on success.
   */
  export(target?: string): Promise<EntityData> {
    const data = Object.assign({ }, this.internalExportData, {
      position: { x: this.position.x, y: this.position.y },
      rotation: this.rotation,
      scale: { x: this.scale.x, y: this.scale.y },
    });
    this.emit('exported', data);
    return Promise.resolve(data);
  }

  /**
   * Parses and applies the data, which has been previously exported, to this entity.
   * The `parsed` event will be triggered before resolving.
   * Override this to your needs, but make sure to call this implementation at the end, so the `parsed` event gets
   * emitted right before resolving.
   *
   * @param {EntityData} data The data to parse and apply.
   * @param {string} from The URI from which the data is parsed.
   * @returns {Promise<Entity>} Resolves this entity on success.
   */
  parse(data: EntityData, from: string): Promise<Entity> {
    if (!data.id) return Promise.reject(new EntityException('No id provided for parsing'));
    this.id = data.id;
    this.name = data.name;
    this.visibility = data.visibility;
    this.visible = data.visibility;
    this.locked = data.locked;
    this.transparency = data.transparency;
    this.emit('parsed', data); // Notify any listeners that we parsed data
    return Promise.resolve(this);
  }

  apply(data: Partial<EntityData>): { [key: string]: { old: any, new: any } } {
    const keys = Object.keys(data);
    const changes = { };
    const typeOptions: Object = (<any>this).internalPropertyOptions;
    keys.forEach(key => {
      if (!typeOptions.hasOwnProperty(key)) return;
      if (this[key] !== data[key]) {
        changes[key] = { old: this[key], new: data[key] };
        this[key] = data[key];
      }
    });
    return changes;
  }

  /**
   * Clones, i.e. creates a copy of, this entity, with the exact same properties, but with a new id.
   *
   * @returns {Promise<Entity>} Resolves the new entity instance.
   */
  abstract clone(): Promise<Entity>;

  /**
   * Tests if the given global point is inside this entity based on its calculated bounding box.
   *
   * @param {PIXI.Point} point The global point to test.
   * @returns {boolean} The result of the test
   */
  containsPoint(point: PIXI.Point): boolean {
    const bounds = this.getShape();
    if (!bounds) return false;
    if (typeof bounds.contains !== 'function') {
      console.warn('The following shape does not implement a "contains" function:', bounds, 'entity:', this);
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    return bounds.contains(tempPoint.x, tempPoint.y);
  }

  /**
   * Returns the shape of this entity in local coordinates.
   * By default this is equal to the local bounds of this entity.
   * This can be overridden by any more specific entity.
   *
   * @returns {(PIXI.Rectangle | PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.RoundedRectangle | any)}
   */
  getShape(): PIXI.Rectangle | PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.RoundedRectangle | any {
    return this.getLocalBounds();
  }

  getProperties(): PropertyOptionsExt[] {
    const types = <{ [key: string]: PropertyOptions }> (<any>this).internalPropertyOptions;
    delete types.id;
    const properties = [];
    for (const x in types) {
      if (!types[x].export) continue;
      const obj = <PropertyOptionsExt>Object.assign({}, types[x], { name: x, value: this[x] });
      obj.value = TransformProperty(obj, obj.value, false);
      properties.push(obj);
    }
    return properties;
  }

  updateFromAction(action: UpdateEntityProperty) {
    if (this.id !== action.id) return;
    const typeOptions: Object = (<any>this).internalPropertyOptions;
    const data = action.data;
    let updated = false;
    for (const key in data) {
      if (!typeOptions.hasOwnProperty(key)) continue;
      const value = data[key];
      const options = typeOptions[key];
      if (!options) return;
      this[key] = TransformProperty(options, value, true);
      updated = true;
    }
    return updated;
  }
}

/**
 * Registers an entity class.
 * You should use the method to register your entity class, so resolving entity types will works as expected.
 *
 * @param {T extends Type<Entity>} constructor The class constructor.
 */
export function EntityType<T extends Type<Entity>>(name?: string) {
  return (constructor: T) => {
    Entity.registerEntityType(constructor, name);
  };
}
