import { uuid } from "../../utils/uuid";
import { Type } from "@angular/core";
import * as _ from 'lodash';

interface EntityTypes {
  [key: string]: Type<Entity>;
}
/**
 * Data which has to be exported for an entity.
 *
 * @interface EntityData
 */
export interface EntityData {

  /** @type {string} The id of the entity. */
  id: string;

  /** @type {string} The type of the entity. */
  type: string;

  /** @type {string} The name of the entity. */
  name: string;

  [key: string]: any;
}

/**
 * An entity represents any object which can be rendered in a scene.
 * The scene holds a collection/list of entities.
 *
 * @export
 * @abstract
 * @class Entity
 * @extends {PIXI.Container}
 */
export abstract class Entity extends PIXI.Container {

  /** @type {Entity} The parent entity, which may be different from the parent. This will not be exported or parsed. */
  protected internalParent: Entity;

  /** @type {string} The internal name of this entity.*/
  protected internalName: string;

  /** @type {string} The internal uuid. It will be generated by default. Implementations can override it, though. */
  protected internalId: string;

  /** @type {EntityTypes} A map of entity types, which are registred. */
  protected static TYPES: EntityTypes = { };

  /** @type {EntityData} The data to export. Should be updated as soon, as changes happen to this entity. */
  protected exportData: EntityData;

  constructor(name?: string) {
    super();
    this.internalParent = null;
    this.internalId = uuid();
    this.internalName = name;
    this.exportData = {
      id: this.internalId,
      name: this.internalName,
      type: Entity.getEntityTypeOf(this)
    };
  }

  /**
   * The client independent identifier of this entity.
   * By default this should be an id, generated the same way the firebase push ids get generated.
   *
   * @type {string}
   */
  get id(): string {
    return this.internalId;
  }

  /**
   * This will emit the `id` event, if the id changed.
   */
  set id(id: string) {
    if (this.internalId !== id) {
      let prevId = this.internalId;
      this.exportData.id = this.internalId = id;
      this.emit('id', id, prevId);
    }
  }

  /**
   * Then name of this entity.
   *
   * @type {string}
   */
  get name(): string {
    return this.internalName;
  }

  /**
   * This will emit the `name` event, if the name changed.
   * Does not have to be unique and can be `null`.
   */
  set name(name: string) {
    if (this.internalName !== name) {
      let prevName = this.internalName;
      this.exportData.name = this.internalName = name;
      this.emit('name', name, prevName);
    }
  }

  /**
   * The entity, this entity is attached to.
   *
   * @type {Entity}
   */
  get parentEntity(): Entity {
    return this.internalParent;
  }

  /**
   * This will emit the `parentEntity` event, if the parent entity changed.
   * Can also be `null`.
   */
  set parentEntity(parent: Entity) {
    if (this.internalParent !== parent) {
      let prevParent = this.internalParent;
      this.internalParent = parent;
      this.emit('parentEntity', parent, prevParent);
    }
  }

  /**
   * Exports the current data of this entity.
   * The `exported` event will be triggered before resolving.
   * Override this to your needs, but make sure to call this implementation at the end, so the `exported` event gets
   * emitted right before resolving.
   *
   * @param {string} target The target URI. Can be used for calculating relative paths, etc.
   * @returns {Promise<EntityData>} Resolves the exported data on success.
   */
  export(target: string): Promise<EntityData> {
    this.emit('exported', this.exportData);
    return Promise.resolve(this.exportData);
  }

  /**
   * Parses and applies the data, which has been previously exported, to this entity.
   * The `parsed` event will be triggered before resolving.
   * Override this to your needs, but make sure to call this implementation at the end, so the `parsed` event gets
   * emitted right before resolving.
   *
   * @param {EntityData} data The data to parse and apply.
   * @param {string} from The URI from which the data is parsed.
   * @returns {Promise<Entity>} Resolves this entity on success.
   */
  parse(data: EntityData, from: string): Promise<Entity> {
    if (!data.id) return Promise.reject(new Error('No id provided for parsing'));
    this.id = data.id;
    this.name = data.name;
    this.emit('parsed', data); // Notify any listeners that we parsed data
    return Promise.resolve(this);
  }

  /**
   * Clones, i.e. creates a copy of, this entity, with the exact same properties, but with a new id.
   *
   * @returns {Promise<Entity>} Resolves the new entity instance.
   */
  abstract clone(): Promise<Entity>;

  /**
   * Registers an entity class.
   * You should use the method to register your entity class, so resolving entity types will works as expected.
   *
   * @param {Type<Entity>} clazz The class to regiter.
   * @param {string} [type=clazz.name.toLowerCase()] You may want to set this, to prevent naming collisions.
   */
  static registerEntityType<T extends Entity>(clazz: Type<T>, type: string = clazz.name.toLowerCase()): void {
    Entity.TYPES[type] = clazz;
  }

  /**
   * Resolves an entity class for the given entity type.
   *
   * @param {string} type The entity type.
   * @returns {Type<Entity>} The entity class. Maybe `undefined` if not registered yet.
   */
  static getEntityType(type: string): Type<Entity> {
    return Entity.TYPES[type];
  }

  /**
   * Searches for the registered entity type of the given entity.
   *
   * @param {T} entity The entity to find the type for.
   * @returns {string} The type or `undefined` if not found.
   */
  static getEntityTypeOf<T extends Entity>(entity: T): string {
    let constructor = Object.getPrototypeOf(entity).constructor;
    return _.findKey(Entity.TYPES, type => type === constructor.constructor);
  }

}
