import { uuid } from "../../utils/uuid";
import { Type } from "@angular/core";
import * as _ from 'lodash';
import { Property } from "./property";
import * as PIXI from 'pixi.js';
import { EntityException } from "../exception/entity/entity";

interface EntityTypes {
  [key: string]: Type<Entity>;
}
/**
 * Data which has to be exported for an entity.
 *
 * @interface EntityData
 */
export interface EntityData {

  /** @type {string} The id of the entity. */
  id: string;

  /** @type {string} The type of the entity. */
  type: string;

  /** @type {string} The name of the entity. */
  name: string;

  [key: string]: any;
}

/** @type {EntityTypes} A map of entity types, which are registred. */
const TYPES: EntityTypes = { };

/**
 * An entity represents any object which can be rendered in a scene.
 * The scene holds a collection/list of entities.
 *
 * @export
 * @abstract
 * @class Entity
 * @extends {PIXI.Container}
 */
export abstract class Entity extends PIXI.Container {

  /** @type {Entity} The parent entity, which may be different from the parent. This will not be exported or parsed. */
  @Property(false) parentEntity: Entity;

  /** @type {string} The internal name of this entity.*/
  @Property(true) name: string;

  /** @type {string} The internal uuid. It will be generated by default. Implementations can override it, though. */
  @Property(true) id: string;

  /** @type {EntityData} The data to export. Should be updated as soon, as changes happen to this entity. */
  protected internalExportData: EntityData;

  constructor(name?: string) {
    super();
    this.internalExportData = {
      id: void 0,
      name: void 0,
      type: Entity.getEntityTypeOf(this)
    };
    this.parentEntity = null;
    this.id = uuid();
    this.name = name;
  }

  /** @type {EntityData} The export data of this entity. */
  get exportData(): EntityData {
    return this.internalExportData;
  }

  /**
   * Exports the current data of this entity.
   * The `exported` event will be triggered before resolving.
   * Override this to your needs, but make sure to call this implementation at the end, so the `exported` event gets
   * emitted right before resolving.
   *
   * @param {string} target The target URI. Can be used for calculating relative paths, etc.
   * @returns {Promise<EntityData>} Resolves the exported data on success.
   */
  export(target: string): Promise<EntityData> {
    this.emit('exported', this.internalExportData);
    return Promise.resolve(this.internalExportData);
  }

  /**
   * Parses and applies the data, which has been previously exported, to this entity.
   * The `parsed` event will be triggered before resolving.
   * Override this to your needs, but make sure to call this implementation at the end, so the `parsed` event gets
   * emitted right before resolving.
   *
   * @param {EntityData} data The data to parse and apply.
   * @param {string} from The URI from which the data is parsed.
   * @returns {Promise<Entity>} Resolves this entity on success.
   */
  parse(data: EntityData, from: string): Promise<Entity> {
    if (!data.id) return Promise.reject(new EntityException('No id provided for parsing'));
    this.id = data.id;
    this.name = data.name;
    this.emit('parsed', data); // Notify any listeners that we parsed data
    return Promise.resolve(this);
  }

  /**
   * Clones, i.e. creates a copy of, this entity, with the exact same properties, but with a new id.
   *
   * @returns {Promise<Entity>} Resolves the new entity instance.
   */
  abstract clone(): Promise<Entity>;

  /**
   * Registers an entity class.
   * You should use the method to register your entity class, so resolving entity types will works as expected.
   *
   * @param {Type<Entity>} clazz The class to regiter.
   * @param {string} [type=clazz.name.toLowerCase()] You may want to set this, to prevent naming collisions.
   */
  static registerEntityType<T extends Entity>(clazz: Type<T>, type: string = clazz.name.toLowerCase()): void {
    TYPES[type] = clazz;
  }

  /**
   * Resolves an entity class for the given entity type.
   *
   * @param {string} type The entity type.
   * @returns {Type<Entity>} The entity class. Maybe `undefined` if not registered yet.
   */
  static getEntityType(type: string): Type<Entity> {
    return TYPES[type];
  }

  /**
   * Searches for the registered entity type of the given entity.
   *
   * @param {T} entity The entity to find the type for.
   * @returns {string} The type or `undefined` if not found.
   */
  static getEntityTypeOf<T extends Entity>(entity: T): string {
    let proto = Object.getPrototypeOf(entity);
    return _.findKey(TYPES, type => type === proto.constructor);
  }

}

/**
 * Registers an entity class.
 * You should use the method to register your entity class, so resolving entity types will works as expected.
 *
 * @param {T extends Type<Entity>} constructor The class constructor.
 */
export function EntityType<T extends Type<Entity>>(name?: string) {
  return (constructor: T) => {
    Entity.registerEntityType(constructor, name);
  }
}
